<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>超级中国象棋</title>
	<link rel="icon" type="image/png" href="./icon.png">
    <link rel="apple-touch-icon" href="./icon.png">
    <script src="tailwind.js"></script>
    <script crossorigin src="https://cdn.bootcdn.net/ajax/libs/react/18.2.0/umd/react.production.min.js"></script>
    <script crossorigin src="https://cdn.bootcdn.net/ajax/libs/react-dom/18.2.0/umd/react-dom.production.min.js"></script>
    <script src="https://cdn.bootcdn.net/ajax/libs/babel-standalone/7.23.5/babel.min.js"></script>
    
    <style>
        body {
            font-family: "Noto Serif SC", "Noto Sans SC", system-ui, serif;
            background-color: #d6d3d1; /* stone-300 */
            margin: 0;
            padding: 0;
            overflow: hidden; /* Prevent scrolling on mobile */
            user-select: none;
            -webkit-user-select: none;
            touch-action: manipulation;
        }
        #root {
            height: 100vh;
            width: 100vw;
            display: flex;
            justify-content: center;
            align-items: center;
        }
        /* Custom Shadows for depth */
        .piece-shadow {
            box-shadow: 
                2px 4px 6px rgba(0,0,0,0.4), 
                inset 2px 2px 4px rgba(255,255,255,0.6), 
                inset -2px -2px 4px rgba(0,0,0,0.2);
        }
        .board-shadow {
            box-shadow: 0 10px 25px -5px rgba(0, 0, 0, 0.5), 0 8px 10px -6px rgba(0, 0, 0, 0.5);
        }
        @keyframes soul-pulse {
            0% { box-shadow: 0 0 0 0 rgba(147, 51, 234, 0.7); }
            70% { box-shadow: 0 0 0 10px rgba(147, 51, 234, 0); }
            100% { box-shadow: 0 0 0 0 rgba(147, 51, 234, 0); }
        }
        .animate-soul {
            animation: soul-pulse 2s infinite;
        }
        /* Gold pulse for Beastmaster Swap */
        @keyframes gold-pulse {
            0% { box-shadow: 0 0 0 0 rgba(234, 179, 8, 0.7); }
            70% { box-shadow: 0 0 0 10px rgba(234, 179, 8, 0); }
            100% { box-shadow: 0 0 0 0 rgba(234, 179, 8, 0); }
        }
        .animate-gold {
            animation: gold-pulse 2s infinite;
        }
        /* Selection pulse for revival/swap/illusion targets */
        @keyframes target-pulse {
            0%, 100% { opacity: 0.3; transform: translate(-50%, -50%) scale(1); }
            50% { opacity: 0.8; transform: translate(-50%, -50%) scale(1.2); }
        }
        .revive-target {
            animation: target-pulse 1.5s ease-in-out infinite;
        }
        .skill-target-indicator {
            animation: target-pulse 1.0s ease-in-out infinite;
        }
        /* Move indicator animation */
        @keyframes ping-with-center {
            0% { transform: translate(-50%, -50%) scale(1); opacity: 1; }
            75%, 100% { transform: translate(-50%, -50%) scale(2); opacity: 0; }
        }
        .animate-ping-slow {
            animation: ping-with-center 1.5s cubic-bezier(0, 0, 0.2, 1) infinite;
        }
        /* Flipped status effect - Optimized for Visibility */
        .piece-flipped {
            position: relative;
        }
        .piece-flipped::before {
            content: '';
            position: absolute;
            inset: 0;
            background-color: rgba(100, 100, 100, 0.15); /* Subtle dimming */
            border-radius: 50%;
            pointer-events: none;
            z-index: 15;
        }
        .piece-flipped::after {
            content: '';
            position: absolute;
            inset: 0;
            border-radius: 50%;
            border: 2px dashed rgba(80, 80, 80, 0.6); /* Dashed border to indicate status */
            pointer-events: none;
            z-index: 16;
        }
        .ban-icon-overlay {
            position: absolute;
            top: -4px;
            right: -4px;
            background: white;
            border-radius: 50%;
            box-shadow: 0 1px 2px rgba(0,0,0,0.3);
            z-index: 20;
            color: #ef4444;
        }
    </style>
</head>
<body>
    <div id="root"></div>

    <script type="text/babel">
        const { useState, useEffect, useRef, useMemo } = window.React;
        const { createRoot } = window.ReactDOM;

        // --- Icons ---
        const Icon = ({ size = 24, className = "", children, ...props }) => (
            <svg xmlns="http://www.w3.org/2000/svg" width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" className={className} {...props}>{children}</svg>
        );
        const Settings = (p) => <Icon {...p}><circle cx="12" cy="12" r="3"/><path d="M19.4 15a1.65 1.65 0 0 0 .33 1.82l.06.06a2 2 0 0 1 0 2.83 2 2 0 0 1-2.83 0l-.06-.06a1.65 1.65 0 0 0-1.82-.33 1.65 1.65 0 0 0-1 1.51V21a2 2 0 0 1-2 2 2 2 0 0 1-2-2v-.09A1.65 1.65 0 0 0 9 19.4a1.65 1.65 0 0 0-1.82.33l-.06.06a2 2 0 0 1-2.83 0 2 2 0 0 1 0-2.83l.06-.06a1.65 1.65 0 0 0 .33-1.82 1.65 1.65 0 0 0-1.51-1H3a2 2 0 0 1-2-2 2 2 0 0 1 2-2h.09A1.65 1.65 0 0 0 4.6 9a1.65 1.65 0 0 0-.33-1.82l-.06-.06a2 2 0 0 1 0-2.83 2 2 0 0 1 2.83 0l.06.06a1.65 1.65 0 0 0 1.82.33H9a1.65 1.65 0 0 0 1-1.51V3a2 2 0 0 1 2-2 2 2 0 0 1 2 2v.09a1.65 1.65 0 0 0 1 1.51 1.65 1.65 0 0 0 1.82-.33l.06-.06a2 2 0 0 1 2.83 0 2 2 0 0 1 0 2.83l-.06.06a1.65 1.65 0 0 0-.33 1.82V9a1.65 1.65 0 0 0 1.51 1H21a2 2 0 0 1 2 2 2 2 0 0 1-2 2h-.09a1.65 1.65 0 0 0-1.51 1z"/></Icon>;
        const Edit = (p) => <Icon {...p}><path d="M11 4H4a2 2 0 0 0-2 2v14a2 2 0 0 0 2 2h14a2 2 0 0 0 2-2v-7"/><path d="M18.5 2.5a2.121 2.121 0 0 1 3 3L12 15l-4 1 1-4 9.5-9.5z"/></Icon>;
        const RefreshCcw = (p) => <Icon {...p}><path d="M3 2v6h6"/><path d="M3 13a9 9 0 1 0 3-7.7L3 8"/></Icon>;
        const Trash2 = (p) => <Icon {...p}><polyline points="3 6 5 6 21 6"/><path d="M19 6v14a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V6m3 0V4a2 2 0 0 1 2-2h4a2 2 0 0 1 2 2v2"/><line x1="10" y1="11" x2="10" y2="17"/><line x1="14" y1="11" x2="14" y2="17"/></Icon>;
        const X = (p) => <Icon {...p}><line x1="18" y1="6" x2="6" y2="18"/><line x1="6" y1="6" x2="18" y2="18"/></Icon>;
        const RotateCcw = (p) => <Icon {...p}><path d="M3 12a9 9 0 1 0 9-9 9.75 9.75 0 0 0-6.74 2.74L3 8"/><path d="M3 3v5h5"/></Icon>;
        const Skull = (p) => <Icon {...p}><path d="M22 10.28a9.92 9.92 0 0 0-6.29-9.1A9.95 9.95 0 0 0 12 1a9.95 9.95 0 0 0-3.71.72A9.92 9.92 0 0 0 2 10.28 2.29 2.29 0 0 0 2 11c0 .87.36 1.68 1 2.29.35.33.7.67 1 1.05.73.93 1.48 2.1 1.78 4.66h12.44c.3-2.56 1.05-3.73 1.78-4.66.3-.38.65-.72 1-1.05.64-.61 1-1.42 1-2.29a2.29 2.29 0 0 0 0-.72zM12 2a8 8 0 0 1 8 8c0 .28-.05.55-.1.82a8.07 8.07 0 0 0-1.83 1.9c-.3.38-.57.75-.82 1.14-.52.82-.93 1.83-1.15 3.14H7.9c-.22-1.31-.63-2.32-1.15-3.14-.25-.39-.52-.76-.82-1.14a8.07 8.07 0 0 0-1.83-1.9A8.2 8.2 0 0 1 4 10a8 8 0 0 1 8-8z"/><path d="M9 13v6"/><path d="M15 13v6"/><path d="M9 19h6"/></Icon>;
        const BookOpen = (p) => <Icon {...p}><path d="M2 3h6a4 4 0 0 1 4 4v14a3 3 0 0 0-3-3H2z"/><path d="M22 3h-6a4 4 0 0 0-4 4v14a3 3 0 0 1 3-3h7z"/></Icon>;
        const Undo2 = (p) => <Icon {...p}><path d="M9 14 4 9l5-5"/><path d="M4 9h10.5a5.5 5.5 0 0 1 5.5 5.5v0a5.5 5.5 0 0 1-5.5 5.5H11"/></Icon>;
        const MousePointer2 = (p) => <Icon {...p}><path d="m12 19-7-7 7-7"/><path d="M19 12H5"/></Icon>; 
        const Sparkles = (p) => <Icon {...p}><path d="m12 3-1.912 5.813a2 2 0 0 1-1.275 1.275L3 12l5.813 1.912a2 2 0 0 1 1.275 1.275L12 21l1.912-5.813a2 2 0 0 1 1.275-1.275L12 3Z"/><path d="M5 3v4"/><path d="M9 5H5"/><path d="M5 19v2"/><path d="M5 21h4"/></Icon>;
        const Repeat = (p) => <Icon {...p}><path d="m17 2 4 4-4 4"/><path d="M3 11v-1a4 4 0 0 1 4-4h14"/><path d="m7 22-4-4 4-4"/><path d="M21 13v1a4 4 0 0 1-4 4H3"/></Icon>;
        const Swords = (p) => <Icon {...p}><path d="M14.5 17.5L3 6V3h3l11.5 11.5"/><path d="m13 19 6-6"/><path d="M19 5l-7 7"/><path d="m21 2-9.6 9.6"/></Icon>;
        const Eye = (p) => <Icon {...p}><path d="M2 12s3-7 10-7 10 7 10 7-3 7-10 7-10-7-10-7Z"/><circle cx="12" cy="12" r="3"/></Icon>;
        const Ban = (p) => <Icon {...p}><circle cx="12" cy="12" r="10"/><path d="m4.9 4.9 14.2 14.2"/></Icon>;
        const Ghost = (p) => <Icon {...p}><path d="M9 22a7 7 0 0 1-7-7V9a7 7 0 0 1 14 0v6a7 7 0 0 1-7 7z"/><path d="M9 22v-6"/><path d="M12 22v-6"/><path d="M15 22v-6"/><path d="M9 13h.01"/><path d="M15 13h.01"/></Icon>;

        // --- Game Constants ---
        const BOARD_ROWS = 10;
        const BOARD_COLS = 9;
        const COLORS = { RED: 'red', BLACK: 'black' };
        
        const PIECE = { KING: 'k', ADVISOR: 'a', ELEPHANT: 'e', HORSE: 'h', ROOK: 'r', CANNON: 'c', PAWN: 'p', GUARD: 'g', SHADOW: 's' };
        
        const STANDARD_PIECES = [PIECE.KING, PIECE.ADVISOR, PIECE.ELEPHANT, PIECE.HORSE, PIECE.ROOK, PIECE.CANNON, PIECE.PAWN];
        const DERIVED_PIECES = [PIECE.GUARD, PIECE.SHADOW];

        const ROLES = {
            CLASSIC: 'classic',
            BEASTMASTER: 'beastmaster',
            COMMANDO: 'commando',
            ARTILLERY: 'artillery',
            EMPEROR: 'emperor',
            TYRANT: 'tyrant',
            NECROMANCER: 'necromancer',
            FORTRESS: 'fortress',
            TRICKSTER: 'trickster'
        };

        const ROLE_DESC = {
            [ROLES.CLASSIC]: '传统 - 标准规则',
            [ROLES.BEASTMASTER]: '御兽 - 马象易位',
            [ROLES.COMMANDO]: '特种 - 兵卒四向移动',
            [ROLES.ARTILLERY]: '炮兵 - 车可隔山打牛',
            [ROLES.EMPEROR]: '帝王 - 帅士全图移动',
            [ROLES.TYRANT]: '暴君 - 吞噬进化',
            [ROLES.NECROMANCER]: '巫师 - 复活死亡子',
            [ROLES.FORTRESS]: '堡垒 - 开局生盾',
            [ROLES.TRICKSTER]: '诡术 - 开局生幻' 
        };

        const ROLE_DETAILS = {
            [ROLES.CLASSIC]: '【传统】\n最经典的中国象棋规则。',
            [ROLES.BEASTMASTER]: '【御兽师】\n善于驾驭野兽。\n1. 马：不受"撇脚"限制。\n2. 象/相：不受"塞眼"限制，且【可以过河】。\n3. 【野性护符】：前3回合，马、象无敌。\n4. 【马象易位】(主动技)：每回合限一次，点击技能后，点选己方一马一象，互换位置。',
            [ROLES.COMMANDO]: '【特种兵】\n受过特殊训练的士兵。\n兵/卒：可以向前后左右四个方向移动，不受过河限制，行动极度灵活。',
            [ROLES.ARTILLERY]: '【炮兵连】\n强化火炮打击能力。\n车：同时拥有"车"和"炮"的能力。既可以像车一样直线吃子，也可以像炮一样隔山打牛。',
            [ROLES.EMPEROR]: '【帝王】\n真龙天子，威震四方。\n1. 帅/将：不再局限于九宫格，可以全图移动（每次一格）。\n2. 士/仕：作为帝王的贴身侍卫，也不再局限于九宫格，可以全图斜向移动。\n3. 注意：本游戏中所有"将/帅"均可发动飞将，但帝王不怕飞将。',
            [ROLES.TYRANT]: '【暴君】\n残暴统治，吞噬进化。\n1. 【吞噬进化】：当你吃掉任意棋子（包括己方）时，该棋子会获得被吃棋子的能力（变为衍生棋子）。\n   例如：车吃炮 -> 变为"车炮"（同时拥有车和炮的走法）。\n   若"车炮"再吃马 -> 变为"车马"（主属性不变，副属性替换）。\n2. 【暴政】：吃掉己方棋子时，获得额外回合（连走）。',
            [ROLES.NECROMANCER]: '【巫师】\n掌管生死的黑魔法。\n技能【招魂】（主动技）：\n1. 每局限用一次。\n2. 轮到你行动时，点击骷髅按钮发动。\n3. 点击一个"原本属于你且目前为空"的初始位置复活该棋子。',
            [ROLES.FORTRESS]: '【移动堡垒】\n拥有极强的阵地防御能力。\n1. 开局额外获得两枚【盾】。【盾】初始位于己方四路和六路，与兵/卒同行。\n2. 【盾】斜向移动，无法吃子，但有"重力锁"：与【盾】斜向相邻的敌方棋子无法移动。',
            [ROLES.TRICKSTER]: '【诡术师】\n在敌后制造幻象，干扰战局。\n1. 【幻象生成】：游戏开始时，在敌方四路和六路，炮所在行生成两枚【幻】。\n2. 【幻】：\n   -虚无：无法被吃，无法吃子，不能重叠。\n   -穿梭：像车一样移动任意格，且无视任何阻挡（穿透），只能落在空位。\n   -幽灵：己方棋子移动/吃子时，无视己方【幻】的阻挡。\n   -惊吓：当【幻】的前后左右紧邻敌方棋子时，可将其【翻面】（若已翻面则不可再次惊吓）。'
        };

        const STANDARD_START_BOARD = [
            { id: 'b_r1', type: PIECE.ROOK, color: COLORS.BLACK, x: 0, y: 0 }, { id: 'b_h1', type: PIECE.HORSE, color: COLORS.BLACK, x: 1, y: 0 }, { id: 'b_e1', type: PIECE.ELEPHANT, color: COLORS.BLACK, x: 2, y: 0 }, { id: 'b_a1', type: PIECE.ADVISOR, color: COLORS.BLACK, x: 3, y: 0 }, { id: 'b_k0', type: PIECE.KING, color: COLORS.BLACK, x: 4, y: 0 }, { id: 'b_a2', type: PIECE.ADVISOR, color: COLORS.BLACK, x: 5, y: 0 }, { id: 'b_e2', type: PIECE.ELEPHANT, color: COLORS.BLACK, x: 6, y: 0 }, { id: 'b_h2', type: PIECE.HORSE, color: COLORS.BLACK, x: 7, y: 0 }, { id: 'b_r2', type: PIECE.ROOK, color: COLORS.BLACK, x: 8, y: 0 },
            { id: 'b_c1', type: PIECE.CANNON, color: COLORS.BLACK, x: 1, y: 2 }, { id: 'b_c2', type: PIECE.CANNON, color: COLORS.BLACK, x: 7, y: 2 },
            { id: 'b_p1', type: PIECE.PAWN, color: COLORS.BLACK, x: 0, y: 3 }, { id: 'b_p2', type: PIECE.PAWN, color: COLORS.BLACK, x: 2, y: 3 }, { id: 'b_p3', type: PIECE.PAWN, color: COLORS.BLACK, x: 4, y: 3 }, { id: 'b_p4', type: PIECE.PAWN, color: COLORS.BLACK, x: 6, y: 3 }, { id: 'b_p5', type: PIECE.PAWN, color: COLORS.BLACK, x: 8, y: 3 },
            { id: 'r_r1', type: PIECE.ROOK, color: COLORS.RED, x: 0, y: 9 }, { id: 'r_h1', type: PIECE.HORSE, color: COLORS.RED, x: 1, y: 9 }, { id: 'r_e1', type: PIECE.ELEPHANT, color: COLORS.RED, x: 2, y: 9 }, { id: 'r_a1', type: PIECE.ADVISOR, color: COLORS.RED, x: 3, y: 9 }, { id: 'r_k0', type: PIECE.KING, color: COLORS.RED, x: 4, y: 9 }, { id: 'r_a2', type: PIECE.ADVISOR, color: COLORS.RED, x: 5, y: 9 }, { id: 'r_e2', type: PIECE.ELEPHANT, color: COLORS.RED, x: 6, y: 9 }, { id: 'r_h2', type: PIECE.HORSE, color: COLORS.RED, x: 7, y: 9 }, { id: 'r_r2', type: PIECE.ROOK, color: COLORS.RED, x: 8, y: 9 },
            { id: 'r_c1', type: PIECE.CANNON, color: COLORS.RED, x: 1, y: 7 }, { id: 'r_c2', type: PIECE.CANNON, color: COLORS.RED, x: 7, y: 7 },
            { id: 'r_p1', type: PIECE.PAWN, color: COLORS.RED, x: 0, y: 6 }, { id: 'r_p2', type: PIECE.PAWN, color: COLORS.RED, x: 2, y: 6 }, { id: 'r_p3', type: PIECE.PAWN, color: COLORS.RED, x: 4, y: 6 }, { id: 'r_p4', type: PIECE.PAWN, color: COLORS.RED, x: 6, y: 6 }, { id: 'r_p5', type: PIECE.PAWN, color: COLORS.RED, x: 8, y: 6 },
        ];

        const getInitialBoard = (redRole, blackRole) => {
            let board = JSON.parse(JSON.stringify(STANDARD_START_BOARD));
            
            // Fortress Spawns
            if (redRole === ROLES.FORTRESS) {
                board.push({ id: 'r_g1', type: PIECE.GUARD, color: COLORS.RED, x: 3, y: 6 });
                board.push({ id: 'r_g2', type: PIECE.GUARD, color: COLORS.RED, x: 5, y: 6 });
            }
            if (blackRole === ROLES.FORTRESS) {
                board.push({ id: 'b_g1', type: PIECE.GUARD, color: COLORS.BLACK, x: 3, y: 3 });
                board.push({ id: 'b_g2', type: PIECE.GUARD, color: COLORS.BLACK, x: 5, y: 3 });
            }

            // Trickster (Shadow) Spawns
            // Enemy's 4th and 6th file (x=3 and x=5), same rank as cannon (y=2 for Black, y=7 for Red)
            if (redRole === ROLES.TRICKSTER) {
                // Red Trickster spawns Shadows on Black's side (y=2)
                // Note: Standard setup has Black Cannons at x=1, y=2 and x=7, y=2. x=3,5 are empty.
                board.push({ id: 'r_s1', type: PIECE.SHADOW, color: COLORS.RED, x: 3, y: 2 });
                board.push({ id: 'r_s2', type: PIECE.SHADOW, color: COLORS.RED, x: 5, y: 2 });
            }
            if (blackRole === ROLES.TRICKSTER) {
                // Black Trickster spawns Shadows on Red's side (y=7)
                board.push({ id: 'b_s1', type: PIECE.SHADOW, color: COLORS.BLACK, x: 3, y: 7 });
                board.push({ id: 'b_s2', type: PIECE.SHADOW, color: COLORS.BLACK, x: 5, y: 7 });
            }

            return board;
        };

        const LABELS = {
            [COLORS.RED]: { [PIECE.KING]: '帥', [PIECE.ADVISOR]: '仕', [PIECE.ELEPHANT]: '相', [PIECE.HORSE]: '馬', [PIECE.ROOK]: '車', [PIECE.CANNON]: '炮', [PIECE.PAWN]: '兵', [PIECE.GUARD]: '盾', [PIECE.SHADOW]: '幻' },
            [COLORS.BLACK]: { [PIECE.KING]: '將', [PIECE.ADVISOR]: '士', [PIECE.ELEPHANT]: '象', [PIECE.HORSE]: '馬', [PIECE.ROOK]: '車', [PIECE.CANNON]: '砲', [PIECE.PAWN]: '卒', [PIECE.GUARD]: '盾', [PIECE.SHADOW]: '幻' }
        };

        const getPieceLabel = (piece) => {
            if (!piece) return '';
            let label = LABELS[piece.color][piece.type];
            if (piece.subtype) {
                label += LABELS[piece.color][piece.subtype];
            }
            return label;
        };

        // --- Logic Engine ---
        const getPieceAt = (board, x, y) => board.find(p => p.x === x && p.y === y);
        const isWithinBoard = (x, y) => x >= 0 && x < BOARD_COLS && y >= 0 && y < BOARD_ROWS;
        const isPalace = (x, y, color) => {
            if (x < 3 || x > 5) return false;
            return color === COLORS.RED ? (y >= 7 && y <= 9) : (y >= 0 && y <= 2);
        };
        
        // Helper: Is this piece an ally shadow? (Ghostly to us)
        const isAllyShadow = (p, color) => p && p.type === PIECE.SHADOW && p.color === color;

        // Core move logic separated by type for Hybrid support
        const getMovesForType = (type, piece, board, redRole, blackRole, roundCount) => {
             const moves = [];
             const { color, x, y } = piece;
             const myRole = color === COLORS.RED ? redRole : blackRole;
             
             // --- FLIPPED / SILENCED LOGIC ---
             if (piece.isFlipped) {
                 [[0, 1], [0, -1], [1, 0], [-1, 0]].forEach(([dx, dy]) => {
                    const tx = x + dx;
                    const ty = y + dy;
                    if (isWithinBoard(tx, ty)) {
                        const target = getPieceAt(board, tx, ty);
                        // Cannot eat, only move to empty
                        if (!target) {
                            moves.push({ x: tx, y: ty });
                        }
                    }
                 });
                 return moves;
             }
             // ---------------------------------

             // Custom blocked check that ignores Ally Shadows
             const isBlocked = (bx, by) => {
                 const blockPiece = getPieceAt(board, bx, by);
                 if (blockPiece && isAllyShadow(blockPiece, color)) return false; // Ignore ally shadow blocking
                 return blockPiece !== undefined;
             };
             
             const tryMove = (tx, ty) => {
                if (!isWithinBoard(tx, ty)) return;
                const target = getPieceAt(board, tx, ty);
                
                // --- SHADOW IMMUNITY ---
                if (target && target.type === PIECE.SHADOW) return; // Cannot eat Shadow (Any shadow, ally or enemy)
                // -----------------------

                if (target) {
                    const targetRole = target.color === COLORS.RED ? redRole : blackRole;
                    if ((target.type === PIECE.HORSE || target.type === PIECE.ELEPHANT) &&
                        targetRole === ROLES.BEASTMASTER && roundCount <= 3) return; // IMMUNE
                }
                if (target && target.color === color && myRole !== ROLES.TYRANT) return;
                moves.push({ x: tx, y: ty });
            };

             switch (type) {
                case PIECE.KING:
                    [[0, 1], [0, -1], [1, 0], [-1, 0]].forEach(([dx, dy]) => {
                        if (myRole === ROLES.EMPEROR || isPalace(x + dx, y + dy, color)) tryMove(x + dx, y + dy);
                    });
                    // Flying general
                    if (piece.type === PIECE.KING) {
                        for (let r = 0; r < BOARD_ROWS; r++) {
                            if (r === y) continue;
                            const p = getPieceAt(board, x, r);
                            if (p && p.type === PIECE.KING && p.color !== color) {
                                let blocked = false;
                                const minY = Math.min(y, r), maxY = Math.max(y, r);
                                // Check blocking. Ally shadows do not block view of flying general for the Ally? 
                                // "己方棋子在计算...无视己方幻". Yes.
                                for (let k = minY + 1; k < maxY; k++) {
                                    const blocker = getPieceAt(board, x, k);
                                    if (blocker) {
                                        if (isAllyShadow(blocker, color)) continue; // Ignore my shadow
                                        // What about enemy shadow? Usually blocks.
                                        blocked = true; 
                                        break; 
                                    }
                                }
                                const targetRole = p.color === COLORS.RED ? redRole : blackRole;
                                if (!blocked && targetRole !== ROLES.EMPEROR) moves.push({ x: x, y: r });
                            }
                        }
                    }
                    break;
                case PIECE.ADVISOR:
                    [[1, 1], [1, -1], [-1, 1], [-1, -1]].forEach(([dx, dy]) => { 
                        if (myRole === ROLES.EMPEROR || isPalace(x + dx, y + dy, color)) tryMove(x + dx, y + dy); 
                    });
                    break;
                case PIECE.ELEPHANT:
                    [[2, 2], [2, -2], [-2, 2], [-2, -2]].forEach(([dx, dy]) => {
                        const tx = x + dx, ty = y + dy;
                        if (myRole === ROLES.BEASTMASTER || (color === COLORS.RED && ty >= 5) || (color === COLORS.BLACK && ty <= 4)) {
                            // isBlocked already handles ignoring Ally Shadows
                            if (myRole === ROLES.BEASTMASTER || !isBlocked(x + dx / 2, y + dy / 2)) tryMove(tx, ty);
                        }
                    });
                    break;
                case PIECE.HORSE:
                    [{ dx: 1, dy: 2, bx: 0, by: 1 }, { dx: -1, dy: 2, bx: 0, by: 1 }, { dx: 1, dy: -2, bx: 0, by: -1 }, { dx: -1, dy: -2, bx: 0, by: -1 }, { dx: 2, dy: 1, bx: 1, by: 0 }, { dx: 2, dy: -1, bx: 1, by: 0 }, { dx: -2, dy: 1, bx: -1, by: 0 }, { dx: -2, dy: -1, bx: -1, by: 0 }]
                    // isBlocked already handles ignoring Ally Shadows
                    .forEach(({ dx, dy, bx, by }) => { if (myRole === ROLES.BEASTMASTER || !isBlocked(x + bx, y + by)) tryMove(x + dx, y + dy); });
                    break;
                case PIECE.ROOK:
                case PIECE.CANNON:
                    [[0, 1], [0, -1], [1, 0], [-1, 0]].forEach(([dx, dy]) => {
                        let curX = x + dx, curY = y + dy;
                        if (type === PIECE.ROOK) {
                            while (isWithinBoard(curX, curY)) {
                                const target = getPieceAt(board, curX, curY);
                                if (!target) { 
                                    moves.push({ x: curX, y: curY }); 
                                } 
                                else { 
                                    // Obstacle found
                                    // Check if Ally Shadow
                                    if (isAllyShadow(target, color)) {
                                        // Ignore it for movement path, but CANNOT land on it
                                        // So we do NOT push move, but we DO continue loop
                                    } else {
                                        // Real obstacle
                                        // --- SHADOW CHECK (Enemy) ---
                                        if (target.type === PIECE.SHADOW) { // Enemy Shadow
                                            break; // Stop at Enemy Shadow, cannot eat
                                        }
                                        // --------------------
                                        const targetRole = target.color === COLORS.RED ? redRole : blackRole;
                                        const isImmune = (target.type === PIECE.HORSE || target.type === PIECE.ELEPHANT) && targetRole === ROLES.BEASTMASTER && roundCount <= 3;
                                        if ((target.color !== color || myRole === ROLES.TYRANT) && !isImmune) moves.push({ x: curX, y: curY }); 
                                        break; 
                                    }
                                }
                                curX += dx; curY += dy;
                            }
                        }
                        if (type === PIECE.CANNON || (type === PIECE.ROOK && myRole === ROLES.ARTILLERY)) {
                             let tempX = x + dx, tempY = y + dy, screenFound = false;
                             while (isWithinBoard(tempX, tempY)) {
                                 const target = getPieceAt(board, tempX, tempY);
                                 if (!screenFound) { 
                                    // Looking for screen
                                    if (target) {
                                        if (isAllyShadow(target, color)) {
                                            // Ally shadow is not a screen. Continue.
                                            // If just moving (Cannon non-capture move), cannot land here.
                                        } else {
                                            screenFound = true; 
                                        }
                                    } else {
                                        // Empty space
                                        if (type === PIECE.CANNON) moves.push({ x: tempX, y: tempY }); 
                                    }
                                 } 
                                 else if (target) { 
                                     // Screen found, looking for target
                                     if (isAllyShadow(target, color)) {
                                         // Ally shadow cannot be captured, and is transparent?
                                         // Logic says "Ignore Ally Shadow when calculating movement and capturing".
                                         // So we skip it.
                                     } else {
                                         // Real target
                                         if (target.type === PIECE.SHADOW) { // Enemy Shadow
                                             break; // Cannot eat
                                         }
                                         const targetRole = target.color === COLORS.RED ? redRole : blackRole;
                                         const isImmune = (target.type === PIECE.HORSE || target.type === PIECE.ELEPHANT) && targetRole === ROLES.BEASTMASTER && roundCount <= 3;
                                         if ((target.color !== color || myRole === ROLES.TYRANT) && !isImmune) moves.push({ x: tempX, y: tempY }); 
                                         break; 
                                     }
                                 }
                                 tempX += dx; tempY += dy;
                             }
                        }
                    });
                    break;
                case PIECE.GUARD:
                    [[0, 1], [0, -1], [1, 0], [-1, 0]].forEach(([dx, dy]) => {
                         if (Math.abs(dx) + Math.abs(dy) !== 1) return;
                    });
                    [[1, 1], [1, -1], [-1, 1], [-1, -1]].forEach(([dx, dy]) => {
                        let curX = x + dx; let curY = y + dy;
                        while (isWithinBoard(curX, curY)) {
                            const target = getPieceAt(board, curX, curY);
                            if (!target) { moves.push({ x: curX, y: curY }); } 
                            else { 
                                if (isAllyShadow(target, color)) {
                                    // Guard can pass through ally shadow? Assuming yes for consistency
                                } else {
                                    break; 
                                }
                            }
                            curX += dx; curY += dy;
                        }
                    });
                    break;
                case PIECE.SHADOW: 
                    // New Shadow Movement: Infinite Range, Penetrate All, Land on Empty
                    [[0, 1], [0, -1], [1, 0], [-1, 0]].forEach(([dx, dy]) => {
                         let curX = x + dx; let curY = y + dy;
                         while (isWithinBoard(curX, curY)) {
                             const target = getPieceAt(board, curX, curY);
                             if (!target) {
                                 moves.push({ x: curX, y: curY }); // Valid move
                             }
                             // Whether target exists or not, we CONTINUE (Penetration)
                             // But we can only land if !target
                             curX += dx; curY += dy;
                         }
                    });
                    break;
                case PIECE.PAWN:
                    const forward = color === COLORS.RED ? -1 : 1;
                    let dirs = [[0, forward]];
                    if (myRole === ROLES.COMMANDO || (color === COLORS.RED ? y <= 4 : y >= 5)) dirs.push([-1, 0], [1, 0]);
                    if (myRole === ROLES.COMMANDO) dirs.push([0, -forward]);
                    dirs.forEach(([dx, dy]) => tryMove(x + dx, y + dy));
                    break;
            }
            return moves;
        };

        const calculateMoves = (piece, board, redRole, blackRole, roundCount) => {
            if (!piece) return [];
            
            // 1. Gravity Lock Check (Common to all)
            const neighborOffsets = [[1, 1], [1, -1], [-1, 1], [-1, -1]];
            for (let [dx, dy] of neighborOffsets) {
                const nx = piece.x + dx;
                const ny = piece.y + dy;
                const neighbor = getPieceAt(board, nx, ny);
                if (neighbor && neighbor.type === PIECE.GUARD && neighbor.color !== piece.color) {
                    return []; // Frozen
                }
            }

            // 2. Get Moves based on Type (and Subtype if hybrid)
            let moves = getMovesForType(piece.type, piece, board, redRole, blackRole, roundCount);
            
            if (piece.subtype && !piece.isFlipped) { // Flipped pieces lose subtype abilities
                const subMoves = getMovesForType(piece.subtype, piece, board, redRole, blackRole, roundCount);
                // Merge unique moves
                subMoves.forEach(sm => {
                    if (!moves.some(m => m.x === sm.x && m.y === sm.y)) {
                        moves.push(sm);
                    }
                });
            }

            return moves;
        };

        // --- Audio System ---
        const audioCtx = new (window.AudioContext || window.webkitAudioContext)();
        const playTone = (freq, type, duration, vol = 0.1) => {
            if (audioCtx.state === 'suspended') audioCtx.resume();
            const osc = audioCtx.createOscillator();
            const gain = audioCtx.createGain();
            osc.type = type;
            osc.frequency.setValueAtTime(freq, audioCtx.currentTime);
            gain.gain.setValueAtTime(vol, audioCtx.currentTime);
            gain.gain.exponentialRampToValueAtTime(0.001, audioCtx.currentTime + duration);
            osc.connect(gain);
            gain.connect(audioCtx.destination);
            osc.start();
            osc.stop(audioCtx.currentTime + duration);
        };
        const playSound = (type) => {
			if (type === 'MOVE') playTone(300, 'triangle', 0.15, 0.6); 				
			else if (type === 'CAPTURE') playTone(400, 'triangle', 0.15, 0.8); 
			else if (type === 'MAGIC') {
				playTone(600, 'sine', 0.5);
				setTimeout(() => playTone(800, 'sine', 0.5), 100);
				setTimeout(() => playTone(1200, 'sine', 0.6), 200);
			} else if (type === 'SKILL_BAD') {
                playTone(200, 'sawtooth', 0.4, 0.5);
                setTimeout(() => playTone(150, 'sawtooth', 0.4, 0.5), 150);
            } else if (type === 'WIN') {
				const now = audioCtx.currentTime;
				[0, 150, 300, 600].forEach((delay, i) => setTimeout(() => playTone(400 + i * 100, 'triangle', 0.4, 0.3), delay));
				setTimeout(() => playTone(800, 'square', 1.0, 0.2), 900);
			}
		};

        const Modal = ({ title, children, onClose }) => (
            <div className="fixed inset-0 bg-black/50 z-50 flex items-center justify-center p-4" onClick={onClose}>
                <div className="bg-white rounded-xl shadow-2xl w-full max-w-md overflow-hidden animate-[scaleIn_0.2s_ease-out]" onClick={e => e.stopPropagation()}>
                    <div className="bg-stone-800 text-amber-50 p-4 flex justify-between items-center">
                        <h3 className="font-bold text-lg">{title}</h3>
                        <button onClick={onClose}><X size={20}/></button>
                    </div>
                    <div className="p-6 max-h-[70vh] overflow-y-auto">
                        {children}
                    </div>
                </div>
            </div>
        );

        const App = () => {
            const [redRole, setRedRole] = useState(ROLES.CLASSIC);
            const [blackRole, setBlackRole] = useState(ROLES.CLASSIC);
            const [board, setBoard] = useState(getInitialBoard(ROLES.CLASSIC, ROLES.CLASSIC));
            const [turn, setTurn] = useState(COLORS.RED);
            const [roundCount, setRoundCount] = useState(1);
            const [selectedPos, setSelectedPos] = useState(null);
            const [validMoves, setValidMoves] = useState([]);
            const [winner, setWinner] = useState(null);
			const [showWinnerModal, setShowWinnerModal] = useState(false);
            const [isFlipped, setIsFlipped] = useState(false);
            const [history, setHistory] = useState([]);

            // Skills
            const [necroUsed, setNecroUsed] = useState({ [COLORS.RED]: false, [COLORS.BLACK]: false });
            const [isReviving, setIsReviving] = useState(false);
            const [swapUsedInTurn, setSwapUsedInTurn] = useState(false);
            const [isSwapping, setIsSwapping] = useState(false);
            const [swapSource, setSwapSource] = useState(null);
            
            // UI
            const [initialTurn, setInitialTurn] = useState(COLORS.RED);
            const [showSettings, setShowSettings] = useState(false);
            const [showHelp, setShowHelp] = useState(false);
            const [isEditing, setIsEditing] = useState(false);
            const [editTool, setEditTool] = useState(null); 
            const [editMoveSource, setEditMoveSource] = useState(null); 
            const [message, setMessage] = useState(null);
            const [editCategory, setEditCategory] = useState('standard');

            useEffect(() => {
                const handleGlobalClick = () => {
                    if (selectedPos) { setSelectedPos(null); setValidMoves([]); }
                    if (isReviving) { setIsReviving(false); setMessage(null); }
                    if (isSwapping) { setIsSwapping(false); setSwapSource(null); setMessage(null); }
                    if (editMoveSource) { setEditMoveSource(null); }
                };
                window.addEventListener('click', handleGlobalClick);
                return () => window.removeEventListener('click', handleGlobalClick);
            }, [selectedPos, isReviving, editMoveSource, isSwapping]);

            useEffect(() => {
                if (message) {
                    const t = setTimeout(() => setMessage(null), 3000);
                    return () => clearTimeout(t);
                }
            }, [message]);

            const saveHistory = () => {
                setHistory(prev => [...prev, {
                    board: JSON.parse(JSON.stringify(board)),
                    turn, roundCount, necroUsed: { ...necroUsed }, winner, swapUsedInTurn
                }]);
            };

            const undoMove = (e) => {
                e.stopPropagation();
                if (history.length === 0) return;
                const lastState = history[history.length - 1];
                setBoard(lastState.board);
                setTurn(lastState.turn);
                setRoundCount(lastState.roundCount);
                setNecroUsed(lastState.necroUsed);
                setWinner(lastState.winner);
                setSwapUsedInTurn(lastState.swapUsedInTurn);
                setShowWinnerModal(false);
                setHistory(prev => prev.slice(0, -1));
                setSelectedPos(null); setValidMoves([]);
                setMessage("悔棋成功");
            };

            const changeRole = (color, newRole) => {
                const setter = color === COLORS.RED ? setRedRole : setBlackRole;
                setter(newRole);
                if (newRole === ROLES.FORTRESS || newRole === ROLES.TRICKSTER) {
                    if (roundCount === 1) {
                         setMessage("角色变更：请点击【重开】应用新角色的开局棋子");
                    }
                }
            };

            const nextTurn = () => {
                const next = turn === COLORS.RED ? COLORS.BLACK : COLORS.RED;
                setTurn(next);
                setSwapUsedInTurn(false);
                if (turn === COLORS.BLACK) setRoundCount(prev => prev + 1);
            };

            const handleTileClick = (e, x, y) => {
                e.stopPropagation();				               

                // --- Edit Mode ---
                if (isEditing) {
                    const p = getPieceAt(board, x, y);

                    // Flip Tool Logic
                    if (editTool === 'flip') {
                        if (p) {
                            const newBoard = board.map(item => item.id === p.id ? { ...item, isFlipped: !item.isFlipped } : item);
                            setBoard(newBoard);
                            playSound('MAGIC');
                            setMessage(`棋子状态: ${!p.isFlipped ? '已翻面' : '恢复'}`);
                        }
                        return;
                    }

                    // Devour Tool Logic
                    if (editTool === 'devour') {
                        if (!p) { setEditMoveSource(null); return; }
                        if (!editMoveSource) {
                            setEditMoveSource(p);
                            setMessage(`已选择吞噬者: ${getPieceLabel(p)}，请选择被吞噬的棋子`);
                            playSound('MOVE');
                            return;
                        }
                        if (p.id === editMoveSource.id) { setEditMoveSource(null); return; }

                        const newBoard = board.filter(item => item.id !== editMoveSource.id && item.id !== p.id);
                        const newPiece = { ...editMoveSource, subtype: p.type };
                        newBoard.push(newPiece);
                        setBoard(newBoard);
                        setEditMoveSource(null);
                        setMessage(`合成成功: ${getPieceLabel(newPiece)}`);
                        playSound('MAGIC');
                        return;
                    }

                    if (!editTool) {
                        // Pointer Tool (Move)
                        if (editMoveSource) {
                            // Move Logic
                            const newBoard = board.filter(p => !(p.x === x && p.y === y) && p.id !== editMoveSource.id);
                            newBoard.push({ ...editMoveSource, x, y });
                            setBoard(newBoard);
                            setEditMoveSource(null);
                            playSound('MOVE');
                        } else {
                            // Select Logic
                            const p = getPieceAt(board, x, y);
                            if (p) setEditMoveSource(p);
                        }
                        return;
                    }
                    
                    if (editTool === 'trash') setBoard(board.filter(p => p.x !== x || p.y !== y));
                    else {
                        // Place Piece
                        const newBoard = board.filter(p => p.x !== x || p.y !== y);
                        newBoard.push({ ...editTool, x, y, id: `${editTool.color}_${editTool.type}_${Date.now()}` });
                        setBoard(newBoard);
                        playSound('MOVE');
                    }
                    return;
                }
				
				if (winner) return;

                // --- Necromancer Revive ---
                if (isReviving) {
                    const clickedPiece = getPieceAt(board, x, y);
                    if (clickedPiece) { setMessage("取消招魂"); setIsReviving(false); return; }
                    const currentIds = new Set(board.map(p => p.id));
                    const myInitialPieces = getInitialBoard(redRole, blackRole).filter(p => p.color === turn);
                    const deadPieceHere = myInitialPieces.find(p => !currentIds.has(p.id) && p.x === x && p.y === y);
                    if (deadPieceHere) {
                        saveHistory();
                        setBoard([...board, deadPieceHere]);
                        setNecroUsed(prev => ({ ...prev, [turn]: true }));
                        setMessage("复活成功"); playSound('MAGIC'); setIsReviving(false);
                    } else {
                        setMessage("取消招魂"); setIsReviving(false);
                    }
                    return;
                }

                // --- Beastmaster Swap ---
                if (isSwapping) {
                    const p = getPieceAt(board, x, y);
                    if (!p || p.color !== turn) { setMessage("请选择己方棋子"); return; }
                    
                    if (!swapSource) {
                        if (p.type === PIECE.HORSE || p.type === PIECE.ELEPHANT) {
                            setSwapSource(p);
                            setMessage(`已选中 ${LABELS[p.color][p.type]}，请点击互换目标`);
                            playSound('MOVE');
                        } else {
                            setMessage("必须选择 马 或 象/相");
                        }
                    } else {
                        const neededType = swapSource.type === PIECE.HORSE ? PIECE.ELEPHANT : PIECE.HORSE;
                        if (p.type === neededType) {
                            saveHistory();
                            const newBoard = board.map(piece => {
                                if (piece.id === swapSource.id) return { ...piece, x: p.x, y: p.y };
                                if (piece.id === p.id) return { ...piece, x: swapSource.x, y: swapSource.y };
                                return piece;
                            });
                            setBoard(newBoard);
                            setSwapUsedInTurn(true);
                            setIsSwapping(false);
                            setSwapSource(null);
                            setMessage("马象易位成功");
                            playSound('MAGIC');
                        } else {
                            setMessage("目标必须是另一类棋子(马/象)");
                            setSwapSource(null);
                        }
                    }
                    return;
                }

                // --- TRICKSTER SHADOW INTERACTION ---
                // If I have selected a SHADOW, and I click an ENEMY adjacent to it (Front/Back/Left/Right)
                if (selectedPos) {
                    const mover = getPieceAt(board, selectedPos.x, selectedPos.y);
                    const target = getPieceAt(board, x, y);
                    
                    if (mover && mover.type === PIECE.SHADOW && mover.color === turn && target && target.color !== turn) {
                        // Check adjacency (Front, Back, Left, Right) - Distance of 1
                        const dx = x - mover.x;
                        const dy = y - mover.y;
                        const isAdjacent = Math.abs(dx) + Math.abs(dy) === 1;
                        
                        // Condition: Adjacent AND Target is not already flipped
                        if (isAdjacent && !target.isFlipped) {
                            // Perform FLIP
                            saveHistory();
                            const newBoard = board.map(item => item.id === target.id ? { ...item, isFlipped: true } : item);
                            setBoard(newBoard);
                            setMessage(`诡术生效: ${getPieceLabel(target)} 已翻面`);
                            playSound('MAGIC');
                            setSelectedPos(null);
                            setValidMoves([]);
                            nextTurn(); // Consumes turn
                            return;
                        } else if (isAdjacent && target.isFlipped) {
                             setMessage("该棋子已翻面，无法再次惊吓");
                             return;
                        }
                    }
                }

                // --- Normal Play ---
                const move = validMoves.find(m => m.x === x && m.y === y);
                if (move) {
                    saveHistory();
                    applyMove(selectedPos, { x, y });
                } else {
                    const piece = getPieceAt(board, x, y);
                    if (piece && piece.color === turn) {
                        setSelectedPos({ x, y });
                        setValidMoves(calculateMoves(piece, board, redRole, blackRole, roundCount));
                    } else {
                        setSelectedPos(null);
                        setValidMoves([]);
                    }
                }
            };

            const applyMove = (from, to) => {
                const mover = getPieceAt(board, from.x, from.y);
                const target = getPieceAt(board, to.x, to.y);
                if (!mover) return;

                let newMover = { ...mover, x: to.x, y: to.y };
                let msg = null;

                // --- RECOVERY FROM FLIP ---
                if (newMover.isFlipped) {
                    newMover.isFlipped = false;
                    msg = `${getPieceLabel(newMover)} 恢复正常`;
                }

                // --- Tyrant Evolution Logic ---
                const myRole = mover.color === COLORS.RED ? redRole : blackRole;
                if (target && myRole === ROLES.TYRANT) {
                    newMover.subtype = target.type;
                    msg = `暴君吞噬: ${getPieceLabel(newMover)}`;
                }

                const newBoard = board.filter(p => !(p.x === to.x && p.y === to.y) && p.id !== mover.id);
                newBoard.push(newMover);
                
                setBoard(newBoard);
                setSelectedPos(null);
                setValidMoves([]);
                
                const redKing = newBoard.find(p => p.type === PIECE.KING && p.color === COLORS.RED);
                const blackKing = newBoard.find(p => p.type === PIECE.KING && p.color === COLORS.BLACK);
                if (!redKing) { 
					setWinner(COLORS.BLACK); 
					setShowWinnerModal(true); 
					playSound('WIN'); 
					return; 
				} else if (!blackKing) { 
					setWinner(COLORS.RED); 
					setShowWinnerModal(true); 
					playSound('WIN'); 
					return; 
				}
                
                let extraTurn = false;
                if (target) {
                    if (target.color === mover.color && myRole === ROLES.TYRANT) {
                        extraTurn = true;
                        msg = "暴君牺牲部下 获得额外回合";
                        playSound('MAGIC');
                    } else {
                        playSound('CAPTURE');
                    }
                } else {
                    playSound('MOVE');
                }

                if (msg) setMessage(msg);

                if (!extraTurn) {
                    nextTurn();
                }
            };

            const activateNecromancy = (e) => {
                e.stopPropagation();
                setSelectedPos(null); setValidMoves([]);
                setIsReviving(true);
                setMessage("请点击一个空的初始位置复活");
            };

            const activateSwap = (e) => {
                e.stopPropagation();
                setSelectedPos(null); setValidMoves([]);
                setIsSwapping(true);
                setMessage("请点击一个马或象");
            };

            const getCanRevive = (playerColor) => {
                const currentIds = new Set(board.map(p => p.id));
                const myInitialPieces = getInitialBoard(redRole, blackRole).filter(p => p.color === playerColor);
                return myInitialPieces.some(p => !currentIds.has(p.id) && !getPieceAt(board, p.x, p.y));
            };

            const resetGame = () => {
                setBoard(getInitialBoard(redRole, blackRole));
				setTurn(COLORS.RED);
				setRoundCount(1);
				setHistory([]); 
				setWinner(null);
				setShowWinnerModal(false); 
                setSelectedPos(null); setValidMoves([]);
                setNecroUsed({ [COLORS.RED]: false, [COLORS.BLACK]: false });
                setSwapUsedInTurn(false);
                setIsReviving(false); setIsSwapping(false); setSwapSource(null);
                setMessage(null);
            };

            const exitEditMode = () => {
                setIsEditing(false); setTurn(initialTurn); 
                setSelectedPos(null); setValidMoves([]); setEditMoveSource(null);
                setIsReviving(false); setIsSwapping(false);
                setHistory([]); setEditCategory('standard');
				setWinner(null); setShowWinnerModal(false); 
            };

            const getTileStyle = (x, y) => {
                const displayX = isFlipped ? BOARD_COLS - 1 - x : x;
                const displayY = isFlipped ? BOARD_ROWS - 1 - y : y;
                return { left: `${displayX * 40 + 20}px`, top: `${displayY * 40 + 20}px`, transform: 'translate(-50%, -50%)', position: 'absolute' };
            };

            const bottomPlayerColor = isFlipped ? COLORS.BLACK : COLORS.RED;
            const topPlayerColor = isFlipped ? COLORS.RED : COLORS.BLACK;
            const bottomPlayerRole = isFlipped ? blackRole : redRole;
            const topPlayerRole = isFlipped ? redRole : blackRole;

            // Skill Button Check
            const canRevive = getCanRevive(turn);
            const activeRole = turn === COLORS.RED ? redRole : blackRole;
            const showNecro = !winner && !isEditing && activeRole === ROLES.NECROMANCER && !necroUsed[turn];
            const showSwap = !winner && !isEditing && !swapUsedInTurn && activeRole === ROLES.BEASTMASTER;

            return (
                <div className="relative w-full max-w-[420px] h-full flex flex-col items-center bg-stone-200 shadow-2xl overflow-hidden">
                    {/* Header */}
                    <div className="w-full bg-stone-800 text-stone-200 p-3 flex justify-between items-center z-20 shadow-md">
                        <div className="font-bold text-lg tracking-wider flex items-center gap-2">
                           <span><span className="text-red-600">超级</span>中国象棋</span>
                           <span className="text-xs font-normal bg-stone-700 px-2 py-0.5 rounded text-stone-400">v1.3.1</span>
                        </div>
                        <div className="flex gap-3">
                             <button onClick={(e) => { e.stopPropagation(); setShowHelp(true); }} className="p-2 bg-stone-700 rounded hover:bg-stone-600"><BookOpen size={18} /></button>
                            <button onClick={(e) => { e.stopPropagation(); exitEditMode(); setIsEditing(!isEditing); }} className={`p-2 rounded ${isEditing ? 'bg-amber-500 text-stone-900' : 'bg-stone-700 hover:bg-stone-600'}`}><Edit size={18} /></button>
                            <button onClick={(e) => { e.stopPropagation(); setShowSettings(true); }} className="p-2 bg-stone-700 rounded hover:bg-stone-600"><Settings size={18} /></button>
                        </div>
                    </div>

                    {message && (
                        <div className="absolute left-1/2 top-24 -translate-x-1/2 z-50 pointer-events-none">
                            <div className="bg-stone-800/95 text-white text-sm font-medium px-4 py-2 rounded-lg shadow-xl whitespace-nowrap border border-stone-600 animate-bounce">{message}</div>
                        </div>
                    )}

                    {/* Info Bar */}
                    <div className="w-full bg-white p-2 border-b border-stone-300 flex justify-between items-center text-sm shadow-sm z-10 relative">
                        <div className={`flex items-center gap-2 font-bold transition-transform ${turn === bottomPlayerColor ? 'scale-105' : 'opacity-60'} ${bottomPlayerColor === COLORS.RED ? 'text-red-700' : 'text-stone-900'}`}>
                            <span>{bottomPlayerColor === COLORS.RED ? '红方' : '黑方'}</span>
                            <span className="text-[10px] font-normal px-1 bg-stone-100 rounded border border-stone-300">{ROLE_DESC[bottomPlayerRole].split(' ')[0]}</span>
                        </div>
                        <div className="flex flex-col items-center">
                            <span className="font-serif italic text-stone-400 text-xs">VS</span>
                            <span className="text-xs font-bold text-stone-600">第 {roundCount} 回合</span>
                        </div>
                        <div className={`flex items-center gap-2 font-bold transition-transform ${turn === topPlayerColor ? 'scale-105' : 'opacity-60'} ${topPlayerColor === COLORS.RED ? 'text-red-700' : 'text-stone-900'}`}>
                            <span className="text-[10px] font-normal px-1 bg-stone-100 rounded border border-stone-300">{ROLE_DESC[topPlayerRole].split(' ')[0]}</span>
                            <span>{topPlayerColor === COLORS.RED ? '红方' : '黑方'}</span>
                        </div>
                    </div>

                    {/* Board */}
                    <div className="flex-1 w-full flex items-center justify-center bg-[#dcb386] relative overflow-hidden">
                        
                        {/* Active Skill Buttons Container */}
                        <div className={`absolute z-40 flex flex-col gap-3 transition-all ${!isFlipped ? (turn === COLORS.BLACK ? 'top-4 left-4' : 'bottom-4 right-4') : (turn === COLORS.BLACK ? 'bottom-4 left-4' : 'top-4 right-4')}`}>
                            {showNecro && (
                                <button onClick={activateNecromancy} disabled={!canRevive} className={`flex flex-col items-center gap-1 p-2 rounded-lg shadow-lg ${canRevive ? 'bg-purple-700 text-white animate-soul' : 'bg-stone-400 opacity-70 cursor-not-allowed'}`}>
                                    <Skull size={20} /> <span className="text-[10px] font-bold">招魂</span>
                                </button>
                            )}
                            {showSwap && (
                                <button onClick={activateSwap} className="flex flex-col items-center gap-1 p-2 rounded-lg shadow-lg bg-amber-500 text-white animate-gold hover:bg-amber-600">
                                    <Repeat size={20} /> <span className="text-[10px] font-bold">易位</span>
                                </button>
                            )}
                        </div>

                        <div className="relative board-shadow" style={{ width: 360, height: 400 }}>
                            <svg width="360" height="400" className="absolute top-0 left-0 pointer-events-none z-0">
                                <defs><pattern id="grid" width="40" height="40" patternUnits="userSpaceOnUse"><path d="M 40 0 L 0 0 0 40" fill="none" stroke="#8b5a2b" strokeWidth="1.5" /></pattern></defs>
                                <rect width="360" height="400" fill="#e6cca0" />
                                <g transform="translate(20, 20)">
                                    {Array.from({ length: 10 }).map((_, i) => <line key={`h${i}`} x1="0" y1={i * 40} x2="320" y2={i * 40} stroke="#8b5a2b" strokeWidth="1.5" />)}
                                    {Array.from({ length: 9 }).map((_, i) => { if (i === 0 || i === 8) return <line key={`v${i}`} x1={i * 40} y1="0" x2={i * 40} y2="360" stroke="#8b5a2b" strokeWidth="2" />; return <g key={`v${i}`}><line x1={i * 40} y1="0" x2={i * 40} y2="160" stroke="#8b5a2b" strokeWidth="1.5" /><line x1={i * 40} y1="200" x2={i * 40} y2="360" stroke="#8b5a2b" strokeWidth="1.5" /></g>; })}
                                    <line x1="120" y1="0" x2="200" y2="80" stroke="#8b5a2b" strokeWidth="1.5" /><line x1="200" y1="0" x2="120" y2="80" stroke="#8b5a2b" strokeWidth="1.5" />
                                    <line x1="120" y1="280" x2="200" y2="360" stroke="#8b5a2b" strokeWidth="1.5" /><line x1="200" y1="280" x2="120" y2="360" stroke="#8b5a2b" strokeWidth="1.5" />
                                    <text x="80" y="180" fontSize="24" fontFamily="Noto Serif SC, serif" fill="#8b5a2b" opacity="0.6" style={{dominantBaseline: 'middle', textAnchor: 'middle'}}>楚 河</text>
                                    <text x="240" y="180" fontSize="24" fontFamily="Noto Serif SC, serif" fill="#8b5a2b" opacity="0.6" style={{dominantBaseline: 'middle', textAnchor: 'middle'}}>漢 界</text>
                                </g>
                            </svg>
                            {Array.from({ length: BOARD_ROWS }).map((_, y) => Array.from({ length: BOARD_COLS }).map((_, x) => {
                                const piece = getPieceAt(board, x, y);
                                const isValid = validMoves.some(m => m.x === x && m.y === y);
                                const isSelected = selectedPos?.x === x && selectedPos?.y === y;
                                const isSwapSource = swapSource?.x === x && swapSource?.y === y;
                                const isEditSource = editMoveSource?.x === x && editMoveSource?.y === y;
                                const label = getPieceLabel(piece);
                                
                                // Shadow Skill Target Indicator
                                let isShadowTarget = false;
                                if (selectedPos) {
                                    const mover = getPieceAt(board, selectedPos.x, selectedPos.y);
                                    if (mover && mover.type === PIECE.SHADOW && mover.color === turn && piece && piece.color !== turn) {
                                         const dx = x - mover.x;
                                         const dy = y - mover.y;
                                         // Front, Back, Left, Right allowed. Distance 1.
                                         if ((Math.abs(dx) + Math.abs(dy) === 1) && !piece.isFlipped) {
                                             isShadowTarget = true;
                                         }
                                    }
                                }

                                return (
                                    <React.Fragment key={`${x}-${y}`}>
                                        {isValid && !piece && <div style={getTileStyle(x, y)} className="w-4 h-4 rounded-full bg-green-500/50 shadow-[0_0_10px_rgba(34,197,94,0.6)] cursor-pointer z-10 hover:scale-125 transition-transform" onClick={(e) => handleTileClick(e, x, y)} />}
                                        {isValid && piece && <div style={getTileStyle(x, y)} className="w-11 h-11 rounded-full border-4 border-green-500/60 z-20 pointer-events-none animate-pulse" />}
                                        {(isSelected || isSwapSource) && <div style={getTileStyle(x, y)} className={`w-11 h-11 rounded-full border-2 ${isSwapSource ? 'border-amber-500 shadow-[0_0_15px_rgba(245,158,11,0.6)]' : 'border-blue-500 shadow-[0_0_15px_rgba(59,130,246,0.6)]'} z-0`} />}
                                        
                                        {/* Edit Mode Source Indicator */}
                                        {isEditSource && (
                                            <div style={getTileStyle(x, y)} className="w-11 h-11 rounded-full border-2 border-amber-500 shadow-[0_0_15px_rgba(245,158,11,0.6)] z-0 animate-ping-slow" />
                                        )}

                                        {isShadowTarget && (
                                             <div style={getTileStyle(x, y)} className="w-11 h-11 rounded-full border-2 border-cyan-400 skill-target-indicator z-30 pointer-events-none" />
                                        )}

                                        {piece && (
                                            <div onClick={(e) => handleTileClick(e, x, y)} style={getTileStyle(x, y)} className={`w-9 h-9 rounded-full piece-shadow z-10 cursor-pointer flex items-center justify-center bg-[#f3dcb8] border-2 ${piece.color === COLORS.RED ? 'border-red-800 text-red-700' : 'border-stone-800 text-stone-900'} transition-transform active:scale-95 ${piece.isFlipped ? 'piece-flipped' : ''} ${piece.type === PIECE.SHADOW ? 'opacity-90' : ''}`}>
                                                <div className={`w-7 h-7 rounded-full border flex items-center justify-center ${piece.color === COLORS.RED ? 'border-red-700/30' : 'border-stone-800/30'}`}>
                                                    <span className={`font-serif font-bold leading-none ${label.length > 1 ? 'text-xs scale-90' : 'text-lg'}`} style={{ marginTop: '-2px' }}>{label}</span>
                                                    {piece.isFlipped && <div className="ban-icon-overlay"><Ban size={12} strokeWidth={3} /></div>}
                                                </div>
                                            </div>
                                        )}
                                        
                                        {!piece && !isValid && !isReviving && (
                                            <div 
                                                onClick={(e) => handleTileClick(e, x, y)} 
                                                style={getTileStyle(x, y)} 
                                                className={`w-8 h-8 z-0 cursor-pointer ${isEditing ? 'bg-black/5 rounded-full hover:bg-black/10' : 'opacity-0'}`} 
                                            />
                                        )}
                                    </React.Fragment>
                                );
                            }))}
                            {isReviving && (() => {
                                const currentIds = new Set(board.map(p => p.id));
                                const myInitialPieces = getInitialBoard(redRole, blackRole).filter(p => p.color === turn);
                                return myInitialPieces.filter(p => !currentIds.has(p.id) && !getPieceAt(board, p.x, p.y)).map(p => (
                                    <div key={`revive-${p.id}`} onClick={(e) => handleTileClick(e, p.x, p.y)} style={getTileStyle(p.x, p.y)} className="w-9 h-9 rounded-full bg-purple-500/40 border-2 border-purple-500 z-30 cursor-pointer revive-target flex items-center justify-center text-purple-900 font-bold text-xs">魂</div>
                                ));
                            })()}
                        </div>
                    </div>

                    {/* Footer */}
                    <div className="w-full bg-stone-100 p-3 border-t border-stone-300 z-20">
                         {isEditing ? (
                            <div className="space-y-2">
                                <div className="flex justify-between items-center px-1">
                                    <span className="font-bold text-amber-600 text-sm flex items-center gap-1">编辑中</span>
                                    <div className="flex gap-1 items-center">
                                        <div className="flex bg-white rounded border border-stone-300 overflow-hidden text-xs items-center mr-1">
                                            <button onClick={() => setRoundCount(Math.max(1, roundCount - 1))} className="px-1.5 py-1 hover:bg-stone-100 border-r border-stone-200">-</button>
                                            <span className="px-1.5 min-w-[20px] text-center font-mono text-stone-800">{roundCount}</span>
                                            <button onClick={() => setRoundCount(roundCount + 1)} className="px-1.5 py-1 hover:bg-stone-100 border-l border-stone-200">+</button>
                                        </div>
                                        <div className="flex bg-white rounded border border-stone-300 overflow-hidden text-xs">
                                            <button onClick={() => setInitialTurn(COLORS.RED)} className={`px-2 py-1 ${initialTurn === COLORS.RED ? 'bg-red-500 text-white' : 'text-stone-500'}`}>红先</button>
                                            <button onClick={() => setInitialTurn(COLORS.BLACK)} className={`px-2 py-1 ${initialTurn === COLORS.BLACK ? 'bg-stone-800 text-white' : 'text-stone-500'}`}>黑先</button>
                                        </div>
                                        <button onClick={() => setBoard([])} className="text-xs bg-red-100 text-red-600 px-2 py-1 rounded">清空</button>
                                        <button onClick={() => exitEditMode()} className="text-xs bg-green-600 text-white px-3 py-1 rounded font-bold">完成</button>
                                    </div>
                                </div>
                                
                                {/* Refined Toolbar Layout */}
                                <div className="flex flex-col gap-2 bg-white p-2 rounded-lg shadow-inner">
                                    {/* Category Toggles */}
                                    <div className="flex gap-2 border-b border-stone-100 pb-2 mb-1">
                                         <button onClick={() => setEditCategory('standard')} className={`text-xs px-2 py-1 rounded flex-1 transition-colors ${editCategory === 'standard' ? 'bg-amber-500 text-white font-bold' : 'bg-stone-100 text-stone-500'}`}>基础棋子</button>
                                         <button onClick={() => setEditCategory('derived')} className={`text-xs px-2 py-1 rounded flex-1 transition-colors flex items-center justify-center gap-1 ${editCategory === 'derived' ? 'bg-purple-600 text-white font-bold' : 'bg-stone-100 text-stone-500'}`}><Sparkles size={12} /> 衍生棋子</button>
                                    </div>
                                    
                                    <div className="flex items-start gap-3">
                                        {/* Left: Tools Grid (2x2) */}
                                        <div className="grid grid-cols-2 gap-2 shrink-0">
											<button onClick={() => { setEditTool(null); setEditMoveSource(null); }} className={`p-2 rounded border ${editTool === null ? 'bg-amber-100 border-amber-500' : 'border-transparent'}`}><MousePointer2 size={20} className="text-stone-600"/></button>
											<button onClick={() => { setEditTool('trash'); setEditMoveSource(null); }} className={`p-2 rounded border ${editTool === 'trash' ? 'bg-red-100 border-red-500' : 'border-transparent'}`}><Trash2 size={20} className="text-red-600"/></button>
											<button onClick={() => { setEditTool('devour'); setEditMoveSource(null); }} className={`p-2 rounded border ${editTool === 'devour' ? 'bg-purple-100 border-purple-500' : 'border-transparent'}`}><Swords size={20} className="text-purple-600"/></button>
                                            <button onClick={() => { setEditTool('flip'); setEditMoveSource(null); }} className={`p-2 rounded border ${editTool === 'flip' ? 'bg-cyan-100 border-cyan-500' : 'border-transparent'}`}><Ban size={20} className="text-cyan-600"/></button>
										</div>
                                        
                                        {/* Divider */}
                                        <div className="w-[1px] self-stretch bg-stone-300"></div>
                                        
                                        {/* Right: Piece List */}
                                        <div className="flex flex-col gap-2 overflow-x-auto">
                                            {[COLORS.RED, COLORS.BLACK].map(color => (
                                                <div key={color} className="flex flex-nowrap gap-1">
                                                    {(editCategory === 'standard' ? STANDARD_PIECES : DERIVED_PIECES).map(type => (
                                                        <button key={`${color}-${type}`} onClick={() => { setEditTool({ type, color }); setEditMoveSource(null); }} className={`w-8 h-8 rounded-full flex items-center justify-center border ${editTool?.type === type && editTool?.color === color ? 'ring-2 ring-blue-500 bg-blue-50' : 'border-stone-300 bg-[#f3dcb8]'} ${color === COLORS.RED ? 'text-red-700' : 'text-black'}`}><span className="text-sm font-bold">{LABELS[color][type]}</span></button>
                                                    ))}
                                                </div>
                                            ))}
                                        </div>
                                    </div>
                                </div>
                            </div>
                        ) : (
                            <div className="flex justify-between items-center px-2">
                                <button onClick={() => setIsFlipped(!isFlipped)} className="flex flex-col items-center gap-1 text-stone-600 w-12"><RotateCcw size={20} /> <span className="text-[10px]">翻转</span></button>
                                <button onClick={undoMove} disabled={history.length === 0} className={`flex flex-col items-center gap-1 w-12 ${history.length > 0 ? 'text-stone-800' : 'text-stone-300'}`}><Undo2 size={20} /> <span className="text-[10px]">悔棋</span></button>
                                <div className="flex-1 text-center text-xs text-stone-400">点击手册可以查看技能</div>
                                <button onClick={resetGame} className="flex flex-col items-center gap-1 text-stone-600 w-12"><RefreshCcw size={20} /> <span className="text-[10px]">重开</span></button>
                            </div>
                        )}
                    </div>
                    
                    {showSettings && (
                        <Modal title="游戏设置" onClose={() => setShowSettings(false)}>
                            <div className="space-y-6">
                                <div>
                                    <h4 className="font-bold text-red-700 mb-2 border-b border-red-200 pb-1">红方角色</h4>
                                    <select value={redRole} onChange={e => changeRole(COLORS.RED, e.target.value)} className="w-full p-2 rounded border border-red-200 bg-red-50 text-sm">{Object.entries(ROLE_DESC).map(([key, label]) => <option key={key} value={key}>{label}</option>)}</select>
                                </div>
                                <div>
                                    <h4 className="font-bold text-stone-800 mb-2 border-b border-stone-200 pb-1">黑方角色</h4>
                                    <select value={blackRole} onChange={e => changeRole(COLORS.BLACK, e.target.value)} className="w-full p-2 rounded border border-stone-300 bg-stone-50 text-sm">{Object.entries(ROLE_DESC).map(([key, label]) => <option key={key} value={key}>{label}</option>)}</select>
                                </div>
                            </div>
                        </Modal>
                    )}

                    {showHelp && (
                        <Modal title="角色技能手册" onClose={() => setShowHelp(false)}>
                            <div className="space-y-4">
                                {Object.entries(ROLE_DETAILS).map(([role, detail]) => (
                                    <div key={role} className="bg-stone-50 p-3 rounded border border-stone-200"><div className="whitespace-pre-line text-sm text-stone-800 leading-relaxed">{detail}</div></div>
                                ))}
                            </div>
                        </Modal>
                    )}

                    {showWinnerModal && (
						<div className="absolute inset-0 z-50 flex items-center justify-center bg-black/40 backdrop-blur-sm">
							<div className="bg-white p-8 rounded-xl shadow-2xl text-center">
								<h2 className={`text-4xl font-bold mb-8 animate-bounce ${winner === COLORS.RED ? 'text-red-600' : 'text-stone-900'}`}>{winner === COLORS.RED ? '红方' : '黑方'} 胜利!</h2>
								<div className="flex gap-4 justify-center">
									<button onClick={() => setShowWinnerModal(false)} className="px-6 py-3 bg-stone-200 text-stone-800 rounded-lg shadow hover:bg-stone-300 font-bold text-lg transform transition active:scale-95">
										回到局面
									</button>
									<button onClick={resetGame} className="px-6 py-3 bg-stone-800 text-white rounded-lg shadow hover:bg-stone-700 font-bold text-lg transform transition active:scale-95">
										再来一局
									</button>
								</div>
							</div>
						</div>
					)}
                </div>
            );
        };

        const root = createRoot(document.getElementById('root'));
        root.render(<App />);
    </script>
    <style>
        @keyframes scaleIn { from { transform: scale(0.9); opacity: 0; } to { transform: scale(1); opacity: 1; } }
    </style>
</body>

</html>
